{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration()) {\n    throw new Error(\"Only export declarations can be splitted.\");\n  }\n\n  const isDefault = exportDeclaration.isExportDefaultDeclaration();\n  const declaration = exportDeclaration.get(\"declaration\");\n  const isClassDeclaration = declaration.isClassDeclaration();\n\n  if (isDefault) {\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = t.cloneNode(id);\n      }\n    }\n\n    const updatedDeclaration = standaloneDeclaration ? declaration : t.variableDeclaration(\"var\", [t.variableDeclarator(t.cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = t.exportNamedDeclaration(null, [t.exportSpecifier(t.cloneNode(id), t.identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n\n    return exportDeclaration;\n  }\n\n  if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return t.exportSpecifier(t.identifier(name), t.identifier(name));\n  });\n  const aliasDeclar = t.exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}","map":{"version":3,"sources":["/Users/sandornegyeliczky/Desktop/projektek/ScrumTrackerFrontend/frontend/node_modules/@babel/helper-split-export-declaration/lib/index.js"],"names":["Object","defineProperty","exports","value","default","splitExportDeclaration","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","exportDeclaration","isExportDeclaration","Error","isDefault","isExportDefaultDeclaration","declaration","isClassDeclaration","standaloneDeclaration","isFunctionDeclaration","scope","isScope","parent","id","node","needBindingRegistration","generateUidIdentifier","isFunctionExpression","isClassExpression","cloneNode","updatedDeclaration","variableDeclaration","variableDeclarator","updatedExportDeclaration","exportNamedDeclaration","exportSpecifier","identifier","insertAfter","replaceWith","registerDeclaration","length","bindingIdentifiers","getOuterBindingIdentifiers","specifiers","keys","map","name","aliasDeclar"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,sBAAlB;;AAEA,IAAIC,CAAC,GAAGC,uBAAuB,CAACC,OAAO,CAAC,cAAD,CAAR,CAA/B;;AAEA,SAASC,wBAAT,GAAoC;AAAE,MAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;AAAa,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AAA2BD,EAAAA,wBAAwB,GAAG,YAAY;AAAE,WAAOE,KAAP;AAAe,GAAxD;;AAA0D,SAAOA,KAAP;AAAe;;AAE1L,SAASJ,uBAAT,CAAiCK,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AAAE,WAAOD,GAAP;AAAa;;AAAC,MAAIA,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA9D,EAA0E;AAAE,WAAO;AAAER,MAAAA,OAAO,EAAEQ;AAAX,KAAP;AAA0B;;AAAC,MAAID,KAAK,GAAGF,wBAAwB,EAApC;;AAAwC,MAAIE,KAAK,IAAIA,KAAK,CAACG,GAAN,CAAUF,GAAV,CAAb,EAA6B;AAAE,WAAOD,KAAK,CAACI,GAAN,CAAUH,GAAV,CAAP;AAAwB;;AAAC,MAAII,MAAM,GAAG,EAAb;AAAiB,MAAIC,qBAAqB,GAAGjB,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACkB,wBAA5D;;AAAsF,OAAK,IAAIC,GAAT,IAAgBP,GAAhB,EAAqB;AAAE,QAAIZ,MAAM,CAACoB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCV,GAArC,EAA0CO,GAA1C,CAAJ,EAAoD;AAAE,UAAII,IAAI,GAAGN,qBAAqB,GAAGjB,MAAM,CAACkB,wBAAP,CAAgCN,GAAhC,EAAqCO,GAArC,CAAH,GAA+C,IAA/E;;AAAqF,UAAII,IAAI,KAAKA,IAAI,CAACR,GAAL,IAAYQ,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAAExB,QAAAA,MAAM,CAACC,cAAP,CAAsBe,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;AAA2C,OAAjF,MAAuF;AAAEP,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcP,GAAG,CAACO,GAAD,CAAjB;AAAyB;AAAE;AAAE;;AAACH,EAAAA,MAAM,CAACZ,OAAP,GAAiBQ,GAAjB;;AAAsB,MAAID,KAAJ,EAAW;AAAEA,IAAAA,KAAK,CAACa,GAAN,CAAUZ,GAAV,EAAeI,MAAf;AAAyB;;AAAC,SAAOA,MAAP;AAAgB;;AAEvuB,SAASX,sBAAT,CAAgCoB,iBAAhC,EAAmD;AACjD,MAAI,CAACA,iBAAiB,CAACC,mBAAlB,EAAL,EAA8C;AAC5C,UAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;AACD;;AAED,QAAMC,SAAS,GAAGH,iBAAiB,CAACI,0BAAlB,EAAlB;AACA,QAAMC,WAAW,GAAGL,iBAAiB,CAACV,GAAlB,CAAsB,aAAtB,CAApB;AACA,QAAMgB,kBAAkB,GAAGD,WAAW,CAACC,kBAAZ,EAA3B;;AAEA,MAAIH,SAAJ,EAAe;AACb,UAAMI,qBAAqB,GAAGF,WAAW,CAACG,qBAAZ,MAAuCF,kBAArE;AACA,UAAMG,KAAK,GAAGJ,WAAW,CAACK,OAAZ,KAAwBL,WAAW,CAACI,KAAZ,CAAkBE,MAA1C,GAAmDN,WAAW,CAACI,KAA7E;AACA,QAAIG,EAAE,GAAGP,WAAW,CAACQ,IAAZ,CAAiBD,EAA1B;AACA,QAAIE,uBAAuB,GAAG,KAA9B;;AAEA,QAAI,CAACF,EAAL,EAAS;AACPE,MAAAA,uBAAuB,GAAG,IAA1B;AACAF,MAAAA,EAAE,GAAGH,KAAK,CAACM,qBAAN,CAA4B,SAA5B,CAAL;;AAEA,UAAIR,qBAAqB,IAAIF,WAAW,CAACW,oBAAZ,EAAzB,IAA+DX,WAAW,CAACY,iBAAZ,EAAnE,EAAoG;AAClGZ,QAAAA,WAAW,CAACQ,IAAZ,CAAiBD,EAAjB,GAAsB/B,CAAC,CAACqC,SAAF,CAAYN,EAAZ,CAAtB;AACD;AACF;;AAED,UAAMO,kBAAkB,GAAGZ,qBAAqB,GAAGF,WAAH,GAAiBxB,CAAC,CAACuC,mBAAF,CAAsB,KAAtB,EAA6B,CAACvC,CAAC,CAACwC,kBAAF,CAAqBxC,CAAC,CAACqC,SAAF,CAAYN,EAAZ,CAArB,EAAsCP,WAAW,CAACQ,IAAlD,CAAD,CAA7B,CAAjE;AACA,UAAMS,wBAAwB,GAAGzC,CAAC,CAAC0C,sBAAF,CAAyB,IAAzB,EAA+B,CAAC1C,CAAC,CAAC2C,eAAF,CAAkB3C,CAAC,CAACqC,SAAF,CAAYN,EAAZ,CAAlB,EAAmC/B,CAAC,CAAC4C,UAAF,CAAa,SAAb,CAAnC,CAAD,CAA/B,CAAjC;AACAzB,IAAAA,iBAAiB,CAAC0B,WAAlB,CAA8BJ,wBAA9B;AACAtB,IAAAA,iBAAiB,CAAC2B,WAAlB,CAA8BR,kBAA9B;;AAEA,QAAIL,uBAAJ,EAA6B;AAC3BL,MAAAA,KAAK,CAACmB,mBAAN,CAA0B5B,iBAA1B;AACD;;AAED,WAAOA,iBAAP;AACD;;AAED,MAAIA,iBAAiB,CAACV,GAAlB,CAAsB,YAAtB,EAAoCuC,MAApC,GAA6C,CAAjD,EAAoD;AAClD,UAAM,IAAI3B,KAAJ,CAAU,qDAAV,CAAN;AACD;;AAED,QAAM4B,kBAAkB,GAAGzB,WAAW,CAAC0B,0BAAZ,EAA3B;AACA,QAAMC,UAAU,GAAGzD,MAAM,CAAC0D,IAAP,CAAYH,kBAAZ,EAAgCI,GAAhC,CAAoCC,IAAI,IAAI;AAC7D,WAAOtD,CAAC,CAAC2C,eAAF,CAAkB3C,CAAC,CAAC4C,UAAF,CAAaU,IAAb,CAAlB,EAAsCtD,CAAC,CAAC4C,UAAF,CAAaU,IAAb,CAAtC,CAAP;AACD,GAFkB,CAAnB;AAGA,QAAMC,WAAW,GAAGvD,CAAC,CAAC0C,sBAAF,CAAyB,IAAzB,EAA+BS,UAA/B,CAApB;AACAhC,EAAAA,iBAAiB,CAAC0B,WAAlB,CAA8BU,WAA9B;AACApC,EAAAA,iBAAiB,CAAC2B,WAAlB,CAA8BtB,WAAW,CAACQ,IAA1C;AACA,SAAOb,iBAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration()) {\n    throw new Error(\"Only export declarations can be splitted.\");\n  }\n\n  const isDefault = exportDeclaration.isExportDefaultDeclaration();\n  const declaration = exportDeclaration.get(\"declaration\");\n  const isClassDeclaration = declaration.isClassDeclaration();\n\n  if (isDefault) {\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = t.cloneNode(id);\n      }\n    }\n\n    const updatedDeclaration = standaloneDeclaration ? declaration : t.variableDeclaration(\"var\", [t.variableDeclarator(t.cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = t.exportNamedDeclaration(null, [t.exportSpecifier(t.cloneNode(id), t.identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n\n    return exportDeclaration;\n  }\n\n  if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return t.exportSpecifier(t.identifier(name), t.identifier(name));\n  });\n  const aliasDeclar = t.exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}"]},"metadata":{},"sourceType":"script"}