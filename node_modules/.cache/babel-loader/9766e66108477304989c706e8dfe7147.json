{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t.assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member) {\n    const {\n      node,\n      parent,\n      parentPath\n    } = member;\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      const {\n        operator,\n        right\n      } = parent;\n      let value = right;\n\n      if (operator !== \"=\") {\n        this.memoise(member, 2);\n        value = t.binaryExpression(operator.slice(0, -1), this.get(member), value);\n      }\n\n      parentPath.replaceWith(this.set(member, value));\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      const {\n        arguments: args\n      } = parent;\n      parentPath.replaceWith(this.call(member, args));\n      return;\n    }\n\n    if (parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, {}, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}","map":{"version":3,"sources":["/Users/sandornegyeliczky/Desktop/projektek/ScrumTrackerFrontend/frontend/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"],"names":["Object","defineProperty","exports","value","default","memberExpressionToFunctions","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","AssignmentMemoiser","constructor","_map","record","count","assignmentExpression","handle","memoise","member","node","parent","parentPath","isUpdateExpression","argument","operator","prefix","binaryExpression","unaryExpression","numericLiteral","replaceWith","scope","ref","generateUidIdentifierBasedOnNode","push","id","left","cloneNode","sequenceExpression","isAssignmentExpression","right","slice","isCallExpression","callee","arguments","args","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","path","visitor","state","traverse","assign","memoiser"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t.assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member) {\n    const {\n      node,\n      parent,\n      parentPath\n    } = member;\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      const {\n        operator,\n        right\n      } = parent;\n      let value = right;\n\n      if (operator !== \"=\") {\n        this.memoise(member, 2);\n        value = t.binaryExpression(operator.slice(0, -1), this.get(member), value);\n      }\n\n      parentPath.replaceWith(this.set(member, value));\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      const {\n        arguments: args\n      } = parent;\n      parentPath.replaceWith(this.call(member, args));\n      return;\n    }\n\n    if (parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, {}, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}"]},"metadata":{},"sourceType":"script"}