{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperGetFunctionArity = _interopRequireDefault(require(\"@babel/helper-get-function-arity\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst buildPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n\n};\n\nfunction getNameFromLiteralId(id) {\n  if (t.isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (t.isRegExpLiteral(id)) {\n    return `_${id.pattern}_${id.flags}`;\n  }\n\n  if (t.isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!t.isFunction(method)) return;\n      let build = buildPropertyMethodAssignmentWrapper;\n\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      const params = template.callee.body.body[0].params;\n\n      for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  const state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nfunction _default({\n  node,\n  parent,\n  scope,\n  id\n}, localBinding = false) {\n  if (node.id) return;\n\n  if ((t.isObjectProperty(parent) || t.isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || t.isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (t.isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (t.isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = t.cloneNode(id);\n        node.id[t.NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (t.isAssignmentExpression(parent, {\n    operator: \"=\"\n  })) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n\n  if (id && t.isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && t.isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  name = t.toBindingIdentifierName(name);\n  id = t.identifier(name);\n  id[t.NOT_LOCAL_BINDING] = true;\n  const state = visit(node, name, scope);\n  return wrap(state, node, id, scope) || node;\n}","map":{"version":3,"sources":["/Users/sandornegyeliczky/Desktop/projektek/ScrumTrackerFrontend/frontend/node_modules/@babel/helper-function-name/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_default","_helperGetFunctionArity","_interopRequireDefault","require","_template","t","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","buildPropertyMethodAssignmentWrapper","buildGeneratorPropertyMethodAssignmentWrapper","visitor","path","state","node","name","localDeclar","scope","getBindingIdentifier","outerDeclar","selfReference","stop","getNameFromLiteralId","id","isNullLiteral","isRegExpLiteral","pattern","flags","isTemplateLiteral","quasis","map","quasi","raw","join","undefined","wrap","method","hasBinding","hasGlobal","rename","isFunction","build","generator","template","FUNCTION","FUNCTION_ID","FUNCTION_KEY","generateUidIdentifier","expression","params","callee","body","i","len","push","getProgramParent","references","visit","selfAssignment","binding","getOwnBinding","kind","traverse","parent","localBinding","isObjectProperty","isObjectMethod","computed","isLiteral","isVariableDeclarator","isIdentifier","getBinding","constant","cloneNode","NOT_LOCAL_BINDING","isAssignmentExpression","operator","left","toBindingIdentifierName","identifier"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperGetFunctionArity = _interopRequireDefault(require(\"@babel/helper-get-function-arity\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst buildPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n\n};\n\nfunction getNameFromLiteralId(id) {\n  if (t.isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (t.isRegExpLiteral(id)) {\n    return `_${id.pattern}_${id.flags}`;\n  }\n\n  if (t.isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!t.isFunction(method)) return;\n      let build = buildPropertyMethodAssignmentWrapper;\n\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      const params = template.callee.body.body[0].params;\n\n      for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  const state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nfunction _default({\n  node,\n  parent,\n  scope,\n  id\n}, localBinding = false) {\n  if (node.id) return;\n\n  if ((t.isObjectProperty(parent) || t.isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || t.isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (t.isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (t.isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = t.cloneNode(id);\n        node.id[t.NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (t.isAssignmentExpression(parent, {\n    operator: \"=\"\n  })) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n\n  if (id && t.isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && t.isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  name = t.toBindingIdentifierName(name);\n  id = t.identifier(name);\n  id[t.NOT_LOCAL_BINDING] = true;\n  const state = visit(node, name, scope);\n  return wrap(state, node, id, scope) || node;\n}"]},"metadata":{},"sourceType":"script"}