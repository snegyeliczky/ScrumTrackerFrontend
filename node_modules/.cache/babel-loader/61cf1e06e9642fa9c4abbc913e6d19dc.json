{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isTaggedTemplateExpression(parent) && parent.tag === node || t.isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || t.isUnaryLike(parent) || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || hasPostfixPart(node, parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent, printStack) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent, printStack);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !t.isNewExpression(parent) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/sandornegyeliczky/Desktop/projektek/ScrumTrackerFrontend/frontend/node_modules/@babel/generator/lib/node/parentheses.js"],"names":["Object","defineProperty","exports","value","NullableTypeAnnotation","FunctionTypeAnnotation","UpdateExpression","ObjectExpression","DoExpression","Binary","IntersectionTypeAnnotation","UnionTypeAnnotation","TSAsExpression","TSTypeAssertion","TSIntersectionType","TSUnionType","TSInferType","BinaryExpression","SequenceExpression","AwaitExpression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ArrowFunctionExpression","ConditionalExpression","OptionalCallExpression","OptionalMemberExpression","AssignmentExpression","LogicalExpression","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","isClassDeclaration","isClassExpression","superClass","hasPostfixPart","isMemberExpression","isOptionalMemberExpression","object","isCallExpression","isOptionalCallExpression","isNewExpression","callee","isTaggedTemplateExpression","tag","isTSNonNullExpression","isArrayTypeAnnotation","printStack","isUnionTypeAnnotation","isIntersectionTypeAnnotation","isTypeAnnotation","isArrowFunctionExpression","length","isFirstInStatement","considerArrow","operator","isBinaryExpression","left","isUnaryLike","isAwaitExpression","isBinary","parentOp","parentPos","nodeOp","nodePos","right","isLogicalExpression","isNullableTypeAnnotation","isTSArrayType","isTSOptionalType","isTSIntersectionType","isTSUnionType","isTSRestType","isVariableDeclarator","isFor","isForStatement","isThrowStatement","isReturnStatement","isIfStatement","test","isWhileStatement","isForInStatement","isSwitchStatement","discriminant","isExpressionStatement","expression","isYieldExpression","isConditionalExpression","considerDefaultExports","isExportDeclaration","isTSTypeAssertion","isTSAsExpression","isObjectPattern","i","isExportDefaultDeclaration","declaration","body","isSequenceExpression","expressions","isConditional","isAssignmentExpression"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,sBAAR,GAAiCA,sBAAjC;AACAF,OAAO,CAACG,sBAAR,GAAiCA,sBAAjC;AACAH,OAAO,CAACI,gBAAR,GAA2BA,gBAA3B;AACAJ,OAAO,CAACK,gBAAR,GAA2BA,gBAA3B;AACAL,OAAO,CAACM,YAAR,GAAuBA,YAAvB;AACAN,OAAO,CAACO,MAAR,GAAiBA,MAAjB;AACAP,OAAO,CAACQ,0BAAR,GAAqCR,OAAO,CAACS,mBAAR,GAA8BA,mBAAnE;AACAT,OAAO,CAACU,cAAR,GAAyBA,cAAzB;AACAV,OAAO,CAACW,eAAR,GAA0BA,eAA1B;AACAX,OAAO,CAACY,kBAAR,GAA6BZ,OAAO,CAACa,WAAR,GAAsBA,WAAnD;AACAb,OAAO,CAACc,WAAR,GAAsBA,WAAtB;AACAd,OAAO,CAACe,gBAAR,GAA2BA,gBAA3B;AACAf,OAAO,CAACgB,kBAAR,GAA6BA,kBAA7B;AACAhB,OAAO,CAACiB,eAAR,GAA0BjB,OAAO,CAACkB,eAAR,GAA0BA,eAApD;AACAlB,OAAO,CAACmB,eAAR,GAA0BA,eAA1B;AACAnB,OAAO,CAACoB,SAAR,GAAoBA,SAApB;AACApB,OAAO,CAACqB,kBAAR,GAA6BA,kBAA7B;AACArB,OAAO,CAACsB,uBAAR,GAAkCA,uBAAlC;AACAtB,OAAO,CAACuB,qBAAR,GAAgCA,qBAAhC;AACAvB,OAAO,CAACwB,sBAAR,GAAiCxB,OAAO,CAACyB,wBAAR,GAAmCA,wBAApE;AACAzB,OAAO,CAAC0B,oBAAR,GAA+BA,oBAA/B;AACA1B,OAAO,CAAC2B,iBAAR,GAA4BA,iBAA5B;;AAEA,IAAIC,CAAC,GAAGC,uBAAuB,CAACC,OAAO,CAAC,cAAD,CAAR,CAA/B;;AAEA,SAASC,wBAAT,GAAoC;AAAE,MAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;AAAa,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AAA2BD,EAAAA,wBAAwB,GAAG,YAAY;AAAE,WAAOE,KAAP;AAAe,GAAxD;;AAA0D,SAAOA,KAAP;AAAe;;AAE1L,SAASJ,uBAAT,CAAiCK,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AAAE,WAAOD,GAAP;AAAa;;AAAC,MAAIA,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA9D,EAA0E;AAAE,WAAO;AAAEE,MAAAA,OAAO,EAAEF;AAAX,KAAP;AAA0B;;AAAC,MAAID,KAAK,GAAGF,wBAAwB,EAApC;;AAAwC,MAAIE,KAAK,IAAIA,KAAK,CAACI,GAAN,CAAUH,GAAV,CAAb,EAA6B;AAAE,WAAOD,KAAK,CAACK,GAAN,CAAUJ,GAAV,CAAP;AAAwB;;AAAC,MAAIK,MAAM,GAAG,EAAb;AAAiB,MAAIC,qBAAqB,GAAG1C,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAAC2C,wBAA5D;;AAAsF,OAAK,IAAIC,GAAT,IAAgBR,GAAhB,EAAqB;AAAE,QAAIpC,MAAM,CAAC6C,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCX,GAArC,EAA0CQ,GAA1C,CAAJ,EAAoD;AAAE,UAAII,IAAI,GAAGN,qBAAqB,GAAG1C,MAAM,CAAC2C,wBAAP,CAAgCP,GAAhC,EAAqCQ,GAArC,CAAH,GAA+C,IAA/E;;AAAqF,UAAII,IAAI,KAAKA,IAAI,CAACR,GAAL,IAAYQ,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAAEjD,QAAAA,MAAM,CAACC,cAAP,CAAsBwC,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;AAA2C,OAAjF,MAAuF;AAAEP,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcR,GAAG,CAACQ,GAAD,CAAjB;AAAyB;AAAE;AAAE;;AAACH,EAAAA,MAAM,CAACH,OAAP,GAAiBF,GAAjB;;AAAsB,MAAID,KAAJ,EAAW;AAAEA,IAAAA,KAAK,CAACc,GAAN,CAAUb,GAAV,EAAeK,MAAf;AAAyB;;AAAC,SAAOA,MAAP;AAAgB;;AAEvuB,MAAMS,UAAU,GAAG;AACjB,QAAM,CADW;AAEjB,QAAM,CAFW;AAGjB,QAAM,CAHW;AAIjB,OAAK,CAJY;AAKjB,OAAK,CALY;AAMjB,OAAK,CANY;AAOjB,QAAM,CAPW;AAQjB,SAAO,CARU;AASjB,QAAM,CATW;AAUjB,SAAO,CAVU;AAWjB,OAAK,CAXY;AAYjB,OAAK,CAZY;AAajB,QAAM,CAbW;AAcjB,QAAM,CAdW;AAejBC,EAAAA,EAAE,EAAE,CAfa;AAgBjBC,EAAAA,UAAU,EAAE,CAhBK;AAiBjB,QAAM,CAjBW;AAkBjB,QAAM,CAlBW;AAmBjB,SAAO,CAnBU;AAoBjB,OAAK,CApBY;AAqBjB,OAAK,CArBY;AAsBjB,OAAK,CAtBY;AAuBjB,OAAK,CAvBY;AAwBjB,OAAK,CAxBY;AAyBjB,QAAM;AAzBW,CAAnB;;AA4BA,MAAMC,oBAAoB,GAAG,CAACC,IAAD,EAAOC,MAAP,KAAkB,CAACzB,CAAC,CAAC0B,kBAAF,CAAqBD,MAArB,KAAgCzB,CAAC,CAAC2B,iBAAF,CAAoBF,MAApB,CAAjC,KAAiEA,MAAM,CAACG,UAAP,KAAsBJ,IAAtI;;AAEA,MAAMK,cAAc,GAAG,CAACL,IAAD,EAAOC,MAAP,KAAkB,CAACzB,CAAC,CAAC8B,kBAAF,CAAqBL,MAArB,KAAgCzB,CAAC,CAAC+B,0BAAF,CAA6BN,MAA7B,CAAjC,KAA0EA,MAAM,CAACO,MAAP,KAAkBR,IAA5F,IAAoG,CAACxB,CAAC,CAACiC,gBAAF,CAAmBR,MAAnB,KAA8BzB,CAAC,CAACkC,wBAAF,CAA2BT,MAA3B,CAA9B,IAAoEzB,CAAC,CAACmC,eAAF,CAAkBV,MAAlB,CAArE,KAAmGA,MAAM,CAACW,MAAP,KAAkBZ,IAAzN,IAAiOxB,CAAC,CAACqC,0BAAF,CAA6BZ,MAA7B,KAAwCA,MAAM,CAACa,GAAP,KAAed,IAAxR,IAAgSxB,CAAC,CAACuC,qBAAF,CAAwBd,MAAxB,CAAzU;;AAEA,SAASnD,sBAAT,CAAgCkD,IAAhC,EAAsCC,MAAtC,EAA8C;AAC5C,SAAOzB,CAAC,CAACwC,qBAAF,CAAwBf,MAAxB,CAAP;AACD;;AAED,SAASlD,sBAAT,CAAgCiD,IAAhC,EAAsCC,MAAtC,EAA8CgB,UAA9C,EAA0D;AACxD,SAAOzC,CAAC,CAAC0C,qBAAF,CAAwBjB,MAAxB,KAAmCzB,CAAC,CAAC2C,4BAAF,CAA+BlB,MAA/B,CAAnC,IAA6EzB,CAAC,CAACwC,qBAAF,CAAwBf,MAAxB,CAA7E,IAAgHzB,CAAC,CAAC4C,gBAAF,CAAmBnB,MAAnB,KAA8BzB,CAAC,CAAC6C,yBAAF,CAA4BJ,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAtC,CAArJ;AACD;;AAED,SAAStE,gBAAT,CAA0BgD,IAA1B,EAAgCC,MAAhC,EAAwC;AACtC,SAAOI,cAAc,CAACL,IAAD,EAAOC,MAAP,CAAd,IAAgCF,oBAAoB,CAACC,IAAD,EAAOC,MAAP,CAA3D;AACD;;AAED,SAAShD,gBAAT,CAA0B+C,IAA1B,EAAgCC,MAAhC,EAAwCgB,UAAxC,EAAoD;AAClD,SAAOM,kBAAkB,CAACN,UAAD,EAAa;AACpCO,IAAAA,aAAa,EAAE;AADqB,GAAb,CAAzB;AAGD;;AAED,SAAStE,YAAT,CAAsB8C,IAAtB,EAA4BC,MAA5B,EAAoCgB,UAApC,EAAgD;AAC9C,SAAOM,kBAAkB,CAACN,UAAD,CAAzB;AACD;;AAED,SAAS9D,MAAT,CAAgB6C,IAAhB,EAAsBC,MAAtB,EAA8B;AAC5B,MAAID,IAAI,CAACyB,QAAL,KAAkB,IAAlB,IAA0BjD,CAAC,CAACkD,kBAAF,CAAqBzB,MAArB,EAA6B;AACzDwB,IAAAA,QAAQ,EAAE;AAD+C,GAA7B,CAA9B,EAEI;AACF,WAAOxB,MAAM,CAAC0B,IAAP,KAAgB3B,IAAvB;AACD;;AAED,MAAID,oBAAoB,CAACC,IAAD,EAAOC,MAAP,CAAxB,EAAwC;AACtC,WAAO,IAAP;AACD;;AAED,MAAII,cAAc,CAACL,IAAD,EAAOC,MAAP,CAAd,IAAgCzB,CAAC,CAACoD,WAAF,CAAc3B,MAAd,CAAhC,IAAyDzB,CAAC,CAACqD,iBAAF,CAAoB5B,MAApB,CAA7D,EAA0F;AACxF,WAAO,IAAP;AACD;;AAED,MAAIzB,CAAC,CAACsD,QAAF,CAAW7B,MAAX,CAAJ,EAAwB;AACtB,UAAM8B,QAAQ,GAAG9B,MAAM,CAACwB,QAAxB;AACA,UAAMO,SAAS,GAAGpC,UAAU,CAACmC,QAAD,CAA5B;AACA,UAAME,MAAM,GAAGjC,IAAI,CAACyB,QAApB;AACA,UAAMS,OAAO,GAAGtC,UAAU,CAACqC,MAAD,CAA1B;;AAEA,QAAID,SAAS,KAAKE,OAAd,IAAyBjC,MAAM,CAACkC,KAAP,KAAiBnC,IAA1C,IAAkD,CAACxB,CAAC,CAAC4D,mBAAF,CAAsBnC,MAAtB,CAAnD,IAAoF+B,SAAS,GAAGE,OAApG,EAA6G;AAC3G,aAAO,IAAP;AACD;AACF;AACF;;AAED,SAAS7E,mBAAT,CAA6B2C,IAA7B,EAAmCC,MAAnC,EAA2C;AACzC,SAAOzB,CAAC,CAACwC,qBAAF,CAAwBf,MAAxB,KAAmCzB,CAAC,CAAC6D,wBAAF,CAA2BpC,MAA3B,CAAnC,IAAyEzB,CAAC,CAAC2C,4BAAF,CAA+BlB,MAA/B,CAAzE,IAAmHzB,CAAC,CAAC0C,qBAAF,CAAwBjB,MAAxB,CAA1H;AACD;;AAED,SAAS3C,cAAT,GAA0B;AACxB,SAAO,IAAP;AACD;;AAED,SAASC,eAAT,GAA2B;AACzB,SAAO,IAAP;AACD;;AAED,SAASE,WAAT,CAAqBuC,IAArB,EAA2BC,MAA3B,EAAmC;AACjC,SAAOzB,CAAC,CAAC8D,aAAF,CAAgBrC,MAAhB,KAA2BzB,CAAC,CAAC+D,gBAAF,CAAmBtC,MAAnB,CAA3B,IAAyDzB,CAAC,CAACgE,oBAAF,CAAuBvC,MAAvB,CAAzD,IAA2FzB,CAAC,CAACiE,aAAF,CAAgBxC,MAAhB,CAA3F,IAAsHzB,CAAC,CAACkE,YAAF,CAAezC,MAAf,CAA7H;AACD;;AAED,SAASvC,WAAT,CAAqBsC,IAArB,EAA2BC,MAA3B,EAAmC;AACjC,SAAOzB,CAAC,CAAC8D,aAAF,CAAgBrC,MAAhB,KAA2BzB,CAAC,CAAC+D,gBAAF,CAAmBtC,MAAnB,CAAlC;AACD;;AAED,SAAStC,gBAAT,CAA0BqC,IAA1B,EAAgCC,MAAhC,EAAwC;AACtC,SAAOD,IAAI,CAACyB,QAAL,KAAkB,IAAlB,KAA2BjD,CAAC,CAACmE,oBAAF,CAAuB1C,MAAvB,KAAkCzB,CAAC,CAACoE,KAAF,CAAQ3C,MAAR,CAA7D,CAAP;AACD;;AAED,SAASrC,kBAAT,CAA4BoC,IAA5B,EAAkCC,MAAlC,EAA0C;AACxC,MAAIzB,CAAC,CAACqE,cAAF,CAAiB5C,MAAjB,KAA4BzB,CAAC,CAACsE,gBAAF,CAAmB7C,MAAnB,CAA5B,IAA0DzB,CAAC,CAACuE,iBAAF,CAAoB9C,MAApB,CAA1D,IAAyFzB,CAAC,CAACwE,aAAF,CAAgB/C,MAAhB,KAA2BA,MAAM,CAACgD,IAAP,KAAgBjD,IAApI,IAA4IxB,CAAC,CAAC0E,gBAAF,CAAmBjD,MAAnB,KAA8BA,MAAM,CAACgD,IAAP,KAAgBjD,IAA1L,IAAkMxB,CAAC,CAAC2E,gBAAF,CAAmBlD,MAAnB,KAA8BA,MAAM,CAACkC,KAAP,KAAiBnC,IAAjP,IAAyPxB,CAAC,CAAC4E,iBAAF,CAAoBnD,MAApB,KAA+BA,MAAM,CAACoD,YAAP,KAAwBrD,IAAhT,IAAwTxB,CAAC,CAAC8E,qBAAF,CAAwBrD,MAAxB,KAAmCA,MAAM,CAACsD,UAAP,KAAsBvD,IAArX,EAA2X;AACzX,WAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD;;AAED,SAASlC,eAAT,CAAyBkC,IAAzB,EAA+BC,MAA/B,EAAuC;AACrC,SAAOzB,CAAC,CAACsD,QAAF,CAAW7B,MAAX,KAAsBzB,CAAC,CAACoD,WAAF,CAAc3B,MAAd,CAAtB,IAA+CI,cAAc,CAACL,IAAD,EAAOC,MAAP,CAA7D,IAA+EzB,CAAC,CAACqD,iBAAF,CAAoB5B,MAApB,KAA+BzB,CAAC,CAACgF,iBAAF,CAAoBxD,IAApB,CAA9G,IAA2IxB,CAAC,CAACiF,uBAAF,CAA0BxD,MAA1B,KAAqCD,IAAI,KAAKC,MAAM,CAACgD,IAAhM,IAAwMlD,oBAAoB,CAACC,IAAD,EAAOC,MAAP,CAAnO;AACD;;AAED,SAASlC,eAAT,CAAyBiC,IAAzB,EAA+BC,MAA/B,EAAuCgB,UAAvC,EAAmD;AACjD,SAAOM,kBAAkB,CAACN,UAAD,EAAa;AACpCyC,IAAAA,sBAAsB,EAAE;AADY,GAAb,CAAzB;AAGD;;AAED,SAAS1F,SAAT,CAAmBgC,IAAnB,EAAyBC,MAAzB,EAAiC;AAC/B,SAAOI,cAAc,CAACL,IAAD,EAAOC,MAAP,CAAd,IAAgCzB,CAAC,CAACkD,kBAAF,CAAqBzB,MAArB,EAA6B;AAClEwB,IAAAA,QAAQ,EAAE,IADwD;AAElEE,IAAAA,IAAI,EAAE3B;AAF4D,GAA7B,CAAhC,IAGDD,oBAAoB,CAACC,IAAD,EAAOC,MAAP,CAH1B;AAID;;AAED,SAAShC,kBAAT,CAA4B+B,IAA5B,EAAkCC,MAAlC,EAA0CgB,UAA1C,EAAsD;AACpD,SAAOM,kBAAkB,CAACN,UAAD,EAAa;AACpCyC,IAAAA,sBAAsB,EAAE;AADY,GAAb,CAAzB;AAGD;;AAED,SAASxF,uBAAT,CAAiC8B,IAAjC,EAAuCC,MAAvC,EAA+C;AAC7C,SAAOzB,CAAC,CAACmF,mBAAF,CAAsB1D,MAAtB,KAAiC9B,qBAAqB,CAAC6B,IAAD,EAAOC,MAAP,CAA7D;AACD;;AAED,SAAS9B,qBAAT,CAA+B6B,IAA/B,EAAqCC,MAArC,EAA6C;AAC3C,MAAIzB,CAAC,CAACoD,WAAF,CAAc3B,MAAd,KAAyBzB,CAAC,CAACsD,QAAF,CAAW7B,MAAX,CAAzB,IAA+CzB,CAAC,CAACiF,uBAAF,CAA0BxD,MAA1B,EAAkC;AACnFgD,IAAAA,IAAI,EAAEjD;AAD6E,GAAlC,CAA/C,IAEExB,CAAC,CAACqD,iBAAF,CAAoB5B,MAApB,CAFF,IAEiCzB,CAAC,CAACoF,iBAAF,CAAoB3D,MAApB,CAFjC,IAEgEzB,CAAC,CAACqF,gBAAF,CAAmB5D,MAAnB,CAFpE,EAEgG;AAC9F,WAAO,IAAP;AACD;;AAED,SAAOjC,SAAS,CAACgC,IAAD,EAAOC,MAAP,CAAhB;AACD;;AAED,SAAS5B,wBAAT,CAAkC2B,IAAlC,EAAwCC,MAAxC,EAAgD;AAC9C,SAAOzB,CAAC,CAACiC,gBAAF,CAAmBR,MAAnB,EAA2B;AAChCW,IAAAA,MAAM,EAAEZ;AADwB,GAA3B,KAEDxB,CAAC,CAAC8B,kBAAF,CAAqBL,MAArB,EAA6B;AACjCO,IAAAA,MAAM,EAAER;AADyB,GAA7B,CAFN;AAKD;;AAED,SAAS1B,oBAAT,CAA8B0B,IAA9B,EAAoCC,MAApC,EAA4CgB,UAA5C,EAAwD;AACtD,MAAIzC,CAAC,CAACsF,eAAF,CAAkB9D,IAAI,CAAC2B,IAAvB,CAAJ,EAAkC;AAChC,WAAO,IAAP;AACD,GAFD,MAEO;AACL,WAAOxD,qBAAqB,CAAC6B,IAAD,EAAOC,MAAP,EAAegB,UAAf,CAA5B;AACD;AACF;;AAED,SAAS1C,iBAAT,CAA2ByB,IAA3B,EAAiCC,MAAjC,EAAyC;AACvC,UAAQD,IAAI,CAACyB,QAAb;AACE,SAAK,IAAL;AACE,UAAI,CAACjD,CAAC,CAAC4D,mBAAF,CAAsBnC,MAAtB,CAAL,EAAoC,OAAO,KAAP;AACpC,aAAOA,MAAM,CAACwB,QAAP,KAAoB,IAApB,IAA4BxB,MAAM,CAACwB,QAAP,KAAoB,IAAvD;;AAEF,SAAK,IAAL;AACE,aAAOjD,CAAC,CAAC4D,mBAAF,CAAsBnC,MAAtB,EAA8B;AACnCwB,QAAAA,QAAQ,EAAE;AADyB,OAA9B,CAAP;;AAIF,SAAK,IAAL;AACE,aAAOjD,CAAC,CAAC4D,mBAAF,CAAsBnC,MAAtB,KAAiCA,MAAM,CAACwB,QAAP,KAAoB,IAA5D;AAXJ;AAaD;;AAED,SAASF,kBAAT,CAA4BN,UAA5B,EAAwC;AACtCO,EAAAA,aAAa,GAAG,KADsB;AAEtCkC,EAAAA,sBAAsB,GAAG;AAFa,IAGpC,EAHJ,EAGQ;AACN,MAAIK,CAAC,GAAG9C,UAAU,CAACK,MAAX,GAAoB,CAA5B;AACA,MAAItB,IAAI,GAAGiB,UAAU,CAAC8C,CAAD,CAArB;AACAA,EAAAA,CAAC;AACD,MAAI9D,MAAM,GAAGgB,UAAU,CAAC8C,CAAD,CAAvB;;AAEA,SAAOA,CAAC,GAAG,CAAX,EAAc;AACZ,QAAIvF,CAAC,CAAC8E,qBAAF,CAAwBrD,MAAxB,EAAgC;AAClCsD,MAAAA,UAAU,EAAEvD;AADsB,KAAhC,KAEE0D,sBAAsB,IAAIlF,CAAC,CAACwF,0BAAF,CAA6B/D,MAA7B,EAAqC;AACnEgE,MAAAA,WAAW,EAAEjE;AADsD,KAArC,CAF5B,IAIEwB,aAAa,IAAIhD,CAAC,CAAC6C,yBAAF,CAA4BpB,MAA5B,EAAoC;AACzDiE,MAAAA,IAAI,EAAElE;AADmD,KAApC,CAJvB,EAMI;AACF,aAAO,IAAP;AACD;;AAED,QAAIK,cAAc,CAACL,IAAD,EAAOC,MAAP,CAAd,IAAgC,CAACzB,CAAC,CAACmC,eAAF,CAAkBV,MAAlB,CAAjC,IAA8DzB,CAAC,CAAC2F,oBAAF,CAAuBlE,MAAvB,KAAkCA,MAAM,CAACmE,WAAP,CAAmB,CAAnB,MAA0BpE,IAA1H,IAAkIxB,CAAC,CAAC6F,aAAF,CAAgBpE,MAAhB,EAAwB;AAC5JgD,MAAAA,IAAI,EAAEjD;AADsJ,KAAxB,CAAlI,IAEExB,CAAC,CAACsD,QAAF,CAAW7B,MAAX,EAAmB;AACvB0B,MAAAA,IAAI,EAAE3B;AADiB,KAAnB,CAFF,IAIExB,CAAC,CAAC8F,sBAAF,CAAyBrE,MAAzB,EAAiC;AACrC0B,MAAAA,IAAI,EAAE3B;AAD+B,KAAjC,CAJN,EAMI;AACFA,MAAAA,IAAI,GAAGC,MAAP;AACA8D,MAAAA,CAAC;AACD9D,MAAAA,MAAM,GAAGgB,UAAU,CAAC8C,CAAD,CAAnB;AACD,KAVD,MAUO;AACL,aAAO,KAAP;AACD;AACF;;AAED,SAAO,KAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isTaggedTemplateExpression(parent) && parent.tag === node || t.isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || t.isUnaryLike(parent) || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || hasPostfixPart(node, parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent, printStack) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent, printStack);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !t.isNewExpression(parent) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}