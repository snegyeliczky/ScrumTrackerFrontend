{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _parser = require(\"@babel/parser\");\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const ast = parseWithCodeFrame(code, opts.parser);\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  t.removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  t.traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\n\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  let name;\n\n  if (t.isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (t.isIdentifier(node) || t.isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (t.isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && (!state.placeholderWhitelist || !state.placeholderWhitelist.has(name))) {\n    return;\n  }\n\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n\n  if (t.isStringLiteral(node) || t.isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (t.isNewExpression(parent) && key === \"arguments\" || t.isCallExpression(parent) && key === \"arguments\" || t.isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (t.isExpressionStatement(parent) && !t.isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (t.isStatement(node) && t.isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\n\nfunction parseWithCodeFrame(code, parserOpts) {\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins: (parserOpts.plugins || []).concat(\"placeholders\")\n  });\n\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}","map":{"version":3,"sources":["/Users/sandornegyeliczky/Desktop/projektek/ScrumTrackerFrontend/frontend/node_modules/@babel/template/lib/parse.js"],"names":["Object","defineProperty","exports","value","default","parseAndBuildMetadata","t","_interopRequireWildcard","require","_parser","_codeFrame","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","PATTERN","formatter","code","opts","ast","parseWithCodeFrame","parser","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","removePropertiesDeep","validate","syntactic","placeholders","placeholderNames","Set","legacy","isLegacyRef","undefined","traverse","placeholderVisitorHandler","assign","node","ancestors","state","name","isPlaceholder","Error","isIdentifier","isJSXIdentifier","isStringLiteral","test","slice","parent","length","type","expectedNode","isNewExpression","isCallExpression","isFunction","isExpressionStatement","isStatement","push","resolve","resolveAncestors","isDuplicate","add","i","index","parserOpts","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","plugins","concat","parse","err","loc","message","codeFrameColumns","start"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _parser = require(\"@babel/parser\");\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const ast = parseWithCodeFrame(code, opts.parser);\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  t.removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  t.traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\n\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  let name;\n\n  if (t.isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (t.isIdentifier(node) || t.isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (t.isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && (!state.placeholderWhitelist || !state.placeholderWhitelist.has(name))) {\n    return;\n  }\n\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n\n  if (t.isStringLiteral(node) || t.isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (t.isNewExpression(parent) && key === \"arguments\" || t.isCallExpression(parent) && key === \"arguments\" || t.isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (t.isExpressionStatement(parent) && !t.isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (t.isStatement(node) && t.isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\n\nfunction parseWithCodeFrame(code, parserOpts) {\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins: (parserOpts.plugins || []).concat(\"placeholders\")\n  });\n\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}"]},"metadata":{},"sourceType":"script"}