{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","map":{"version":3,"sources":["/Users/sandornegyeliczky/Desktop/projektek/ScrumTrackerFrontend/frontend/node_modules/@babel/traverse/lib/path/lib/hoister.js"],"names":["Object","defineProperty","exports","value","default","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","react","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","violation","constantViolations","mutableBinding","stop","bindings","PathHoister","constructor","scopes","attachAfter","isCompatibleScope","keys","bindingIdentifierEquals","identifier","getCompatibleScopes","indexOf","getAttachmentPath","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","bindingParentPath","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","bodies","i","length","_blockHoist","getNextScopeAttachmentParent","Array","isArray","container","isStatement","constant","run","traverse","attachTo","getFunctionParent","uid","generateUidIdentifier","declarator","variableDeclarator","insertFn","attached","isVariableDeclarator","variableDeclaration","isJSXElement","children","JSXExpressionContainer","replaceWith","cloneNode"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;"]},"metadata":{},"sourceType":"script"}