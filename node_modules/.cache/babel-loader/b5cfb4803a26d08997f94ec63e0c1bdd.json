{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simplifyAccess;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction simplifyAccess(path, bindingNames) {\n  path.traverse(simpleAssignmentVisitor, {\n    scope: path.scope,\n    bindingNames,\n    seen: new WeakSet()\n  });\n}\n\nconst simpleAssignmentVisitor = {\n  UpdateExpression: {\n    exit(path) {\n      const {\n        scope,\n        bindingNames\n      } = this;\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {\n        const operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(t.assignmentExpression(operator, arg.node, t.numericLiteral(1)));\n      } else if (path.node.prefix) {\n        path.replaceWith(t.assignmentExpression(\"=\", t.identifier(localName), t.binaryExpression(path.node.operator[0], t.unaryExpression(\"+\", arg.node), t.numericLiteral(1))));\n      } else {\n        const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, \"old\");\n        const varName = old.name;\n        path.scope.push({\n          id: old\n        });\n        const binary = t.binaryExpression(path.node.operator[0], t.identifier(varName), t.numericLiteral(1));\n        path.replaceWith(t.sequenceExpression([t.assignmentExpression(\"=\", t.identifier(varName), t.unaryExpression(\"+\", arg.node)), t.assignmentExpression(\"=\", t.cloneNode(arg.node), binary), t.identifier(varName)]));\n      }\n    }\n\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        bindingNames\n      } = this;\n      if (path.node.operator === \"=\") return;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n      const localName = left.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      path.node.right = t.binaryExpression(path.node.operator.slice(0, -1), t.cloneNode(path.node.left), path.node.right);\n      path.node.operator = \"=\";\n    }\n\n  }\n};","map":{"version":3,"sources":["/Users/sandornegyeliczky/Desktop/projektek/ScrumTrackerFrontend/frontend/node_modules/@babel/helper-simple-access/lib/index.js"],"names":["Object","defineProperty","exports","value","default","simplifyAccess","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","path","bindingNames","traverse","simpleAssignmentVisitor","scope","seen","WeakSet","UpdateExpression","exit","arg","isIdentifier","localName","node","name","getBinding","parentPath","isExpressionStatement","isCompletionRecord","operator","replaceWith","assignmentExpression","numericLiteral","prefix","identifier","binaryExpression","unaryExpression","old","generateUidIdentifierBasedOnNode","varName","push","id","binary","sequenceExpression","cloneNode","AssignmentExpression","add","left","right","slice"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simplifyAccess;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction simplifyAccess(path, bindingNames) {\n  path.traverse(simpleAssignmentVisitor, {\n    scope: path.scope,\n    bindingNames,\n    seen: new WeakSet()\n  });\n}\n\nconst simpleAssignmentVisitor = {\n  UpdateExpression: {\n    exit(path) {\n      const {\n        scope,\n        bindingNames\n      } = this;\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {\n        const operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(t.assignmentExpression(operator, arg.node, t.numericLiteral(1)));\n      } else if (path.node.prefix) {\n        path.replaceWith(t.assignmentExpression(\"=\", t.identifier(localName), t.binaryExpression(path.node.operator[0], t.unaryExpression(\"+\", arg.node), t.numericLiteral(1))));\n      } else {\n        const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, \"old\");\n        const varName = old.name;\n        path.scope.push({\n          id: old\n        });\n        const binary = t.binaryExpression(path.node.operator[0], t.identifier(varName), t.numericLiteral(1));\n        path.replaceWith(t.sequenceExpression([t.assignmentExpression(\"=\", t.identifier(varName), t.unaryExpression(\"+\", arg.node)), t.assignmentExpression(\"=\", t.cloneNode(arg.node), binary), t.identifier(varName)]));\n      }\n    }\n\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        bindingNames\n      } = this;\n      if (path.node.operator === \"=\") return;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n      const localName = left.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      path.node.right = t.binaryExpression(path.node.operator.slice(0, -1), t.cloneNode(path.node.left), path.node.right);\n      path.node.operator = \"=\";\n    }\n\n  }\n};"]},"metadata":{},"sourceType":"script"}